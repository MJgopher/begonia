package main

import (
	"errors"
	"github.com/MashiroC/begonia"
	"github.com/MashiroC/begonia/app"
	appClient "github.com/MashiroC/begonia/app/client"
	"reflect"
)

var clientTmplStr = `// Code generated by Begonia. DO NOT EDIT.
// versions:
// 	Begonia v1.0.2
// source: {{.source}} 

{{ $sn := concat .ServiceName "Service" }} {{/* example: EchoService */}}

package {{.package}}

import (
	"github.com/MashiroC/begonia"
	"github.com/MashiroC/begonia/app"
	appClient "github.com/MashiroC/begonia/app/client"
	"github.com/MashiroC/begonia/app/coding"
)

var BegoniaCli begonia.Client

var (
	{{$sn}} appClient.Service

{{range .fi}}
	_{{$sn}}{{.Name}} appClient.RemoteFunSync
	{{$snDo := concat "_" $sn .Name }}
	{{$snDo}}InSchema  = ` + "`" + `{{.InSchema|raw}}` + "`" + `
	{{$snDo}}OutSchema = ` + "`" + `{{.OutSchema|raw}}` + "`" + `
	{{$snDo}}InCoder   coding.Coder
	{{$snDo}}OutCoder  coding.Coder
{{end}}
)

{{/* 序列化用的结构体 In是入参 Out是出参 */}}
{{range .fi}} 	{{$snDo := concat "_" $sn .Name }}
type {{$snDo}}In struct {
	{{range $idx,$value:= .ParamTyp}}
		F{{$idx|add}} {{.}} {{ end -}}}

type {{$snDo}}Out struct {
	{{range $idx,$value:= .ResultTyp}}
		{{if ne $value "error"}}	F{{$idx|add}} {{.}} {{end}} {{end}}
}
{{end}}

func init() {
	app.ServiceAppMode = app.ServiceAppModeAst

	BegoniaCli = begonia.NewClient()

	bService, err := BegoniaCli.Service("{{.RegisterName}}")
	if err != nil {
		panic(err)
	}
{{range .fi}} 	{{$snDo := concat "_" $sn .Name }}
	{{$snDo}}, err = bService.FuncSync("{{.Name}}")

	{{$snDo}}InCoder, err = coding.NewAvro({{$snDo}}InSchema)
	if err != nil {
		panic(err)
	}
	{{$snDo}}OutCoder, err = coding.NewAvro({{$snDo}}OutSchema)
	if err != nil {
		panic(err)
	}
{{end}}
}

{{range $fiIndex,$fun := .fi}} {{$snDo := concat "_" $sn .Name }}
func {{.Name}}({{getFields . "in"}}) ({{getFields . "out"}}) {
	var in {{$snDo}}In
	{{range $idx,$value := getAlias .InSchema}} in.F{{$idx|add}} = {{$value}} 
{{end}}
	b, err := {{$snDo}}InCoder.Encode(in)
	if err != nil {
		panic(err)
	}
	
	begoniaResTmp, err := _{{$sn}}{{.Name}}(b)
	if err != nil {
		return
	}

	var out {{$snDo}}Out
	err = {{$snDo}}OutCoder.DecodeIn(begoniaResTmp.([]byte),&out)
	if err != nil {
		panic(err)
	}

	{{range $idx,$value := getAlias .OutSchema}} 
		 {{$value}} = out.F{{$idx|add}}
	{{end}}
	
	return
}
{{end}}
`

var BegoniaCli begonia.Client

var (
	echoService appClient.Service

	funEcho appClient.RemoteFunSync
)

func initi() {
	app.ServiceAppMode = app.ServiceAppModeAst

	BegoniaCli = begonia.NewClient()

	var err error

	echoService, err = BegoniaCli.Service("Echo")
	if err != nil {
		panic(err)
	}

	funEcho, err = echoService.FuncSync("Echo")
}

func Echo(name string) (res string, err error) {
	in, err := funEcho(name)
	if err != nil {
		return
	}

	var ok bool
	if res, ok = in.(string); !ok {
		err = errors.New("func Echo result type string but " + reflect.TypeOf(in).String())
	}
	return
}

func Echo2(name string) (res1 string, res2 string, err error) {
	var in interface{}

	in, err = funEcho(name)
	arr, ok := in.([]interface{})
	if !ok {
		err = errors.New("func Echo result type []interface{} but " + reflect.TypeOf(in).String())
	}
	res1 = arr[0].(string)
	res2 = arr[0].(string)

	return
}
